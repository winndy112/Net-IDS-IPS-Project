<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snort IDS Log Analyzer</title>
    {% csrf_token %}
    {% load static %}
    <link rel="stylesheet" href="{% static 'dashboard/log_analyzer.css' %}">
    <!-- Include Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
</head>

<body>
    <div class="container mt-4">
        <!-- Navbar -->
        <nav class="navbar navbar-light bg-light mb-4">
            <a href="{% url 'homepage' %}" class="navbar-brand">Home</a>
        </nav>

        <div class="status-container mb-3">
            <div id="snortStatus" class="alert" style="display: none;">
                <span id="statusText"></span>
            </div>
            <button id="streamButton" class="btn btn-primary" style="display: none;" onclick="startStreaming()">
                Stream Live Logs
            </button>
        </div>

        <h2>Snort IDS Log Analyzer</h2>
        <!-- Add the Switch Mode button after the heading -->
        <div class="mb-3">
            <button id="switchModeBtn" class="btn btn-warning" onclick="switchToIPS()">
                Switch to IPS Mode
            </button>
        <div id="logging"></div>
        </div>
        <div class="form-group">
            <label for="logFile">Choose Log File</label>
            <input type="file" id="logFile" accept=".txt,.log" class="form-control-file"
                onchange="updateFileName(this)">
            <small id="selectedFileName" class="form-text text-muted">No file chosen</small>
        </div>
        <div id="errorMessage" class="alert alert-danger" style="display: none;"></div>

        <div class="form-row">
            <div class="form-group col-md-6">
                <input type="text" id="search" class="form-control"
                    placeholder="Search (use: mess:, id:, proto:, src:, dst:, prio:, time:)">
            </div>
            <div class="form-group col-md-6">
                <input type="date" id="dateFilter" class="form-control" placeholder="Filter by date...">
            </div>
        </div>

        <table class="table table-striped" id="logTable">
            <thead class="thead-dark">
                <tr>
                    <th onclick="sortTable(0)">Timestamp</th>
                    <th onclick="sortTable(1)">Rule ID</th>
                    <th onclick="sortTable(2)">Alert Message</th>
                    <th onclick="sortTable(3)">Priority</th>
                    <th onclick="sortTable(4)">Protocol</th>
                    <th onclick="sortTable(5)">Source</th>
                    <th onclick="sortTable(6)">Destination</th>
                </tr>
            </thead>
            <tbody id="logTableBody">
                <!-- Log entries will be inserted here -->
            </tbody>
        </table>
    </div>
    <!-- Include Bootstrap JS dependencies before closing body tag -->
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const isLiveMode = urlParams.get('live') === 'true';

        if (isLiveMode) {
            // Hide file input elements
            document.querySelector('.form-group').style.display = 'none';
            setupWebSocket();
        }

        function setupWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
            const socket = new WebSocket(`${protocol}${window.location.host}/ws/snort_console_output/`);

            socket.onmessage = function (event) {
                try {
                    const data = JSON.parse(event.data);
                    if (data.output) {
                        // Clean and parse the line
                        const line = data.output.trim().replace(/^\d+\|/, '');
                        parseLiveLine(line);
                    }
                } catch (error) {
                    console.error("Error processing WebSocket message:", error);
                }
            };

            socket.onclose = function (event) {
                console.log("WebSocket closed. Attempting to reconnect in 5 seconds...");
                setTimeout(setupWebSocket, 5000);
            };

            socket.onerror = function (error) {
                console.error("WebSocket error:", error);
            };

            return socket;
        }

        function parseLiveLine(line) {
            if (!line.trim()) return;

            try {
                // Remove "Alert: " prefix if present
                line = line.replace(/^Alert:\s*/, '').trim();

                // Updated regex pattern to match live stream format
                const pattern = /^(\d{2}\/\d{2}\/\d{2}-\d{2}:\d{2}:\d{2}\.\d+)\s+\[[\*]+\]\s+\[([^\]]+)\]\s+"([^"]+)"\s+\[[\*]+\]\s+\[Priority:\s*(\d+)\]\s+(?:\[AppID:\s*([^\]]+)\])?\s*{(\w+)}\s+(\S+)\s+->\s+(\S+)/;
                
                const match = line.match(pattern);

                if (match) {
                    const [
                        ,
                        timestamp,
                        ruleId,
                        alertMessage,
                        priority,
                        appId,
                        protocol,
                        source,
                        destination
                    ] = match;

                    const tbody = document.getElementById('logTableBody');
                    const row = tbody.insertRow(0);

                    // Add cells with the parsed data
                    row.insertCell().textContent = timestamp;
                    row.insertCell().textContent = ruleId;
                    row.insertCell().textContent = alertMessage;
                    row.insertCell().textContent = priority;
                    row.insertCell().textContent = protocol;
                    row.insertCell().textContent = source;
                    row.insertCell().textContent = destination;

                    // Limit the number of rows
                    const maxRows = 1000;
                    while (tbody.rows.length > maxRows) {
                        tbody.deleteRow(tbody.rows.length - 1);
                    }

                    // Apply any existing search filters
                    applySearchFilter(row);
                } else {
                    console.warn("Could not parse live line:", line);
                }
            } catch (error) {
                console.error("Error parsing live line:", error);
            }
        }

        // Helper function to apply search filter to new rows
        function applySearchFilter(row) {
            const searchInput = document.getElementById('search');
            const searchText = searchInput.value.toLowerCase();

            if (!searchText) {
                row.style.display = '';
                return;
            }

            const columnMap = {
                'time:': 0,
                'id:': 1,
                'mess:': 2,
                'prio:': 3,
                'proto:': 4,
                'src:': 5,
                'dst:': 6
            };

            let columnToSearch = -1;
            let searchValue = searchText;

            for (const [dork, column] of Object.entries(columnMap)) {
                if (searchText.startsWith(dork)) {
                    columnToSearch = column;
                    searchValue = searchText.substring(dork.length);
                    break;
                }
            }

            let found = false;
            if (columnToSearch === -1) {
                // Search all columns
                for (let i = 0; i < row.cells.length; i++) {
                    const cellText = (row.cells[i].textContent || '').toLowerCase();
                    if (cellText.includes(searchValue)) {
                        found = true;
                        break;
                    }
                }
            } else {
                // Search specific column
                const cellText = (row.cells[columnToSearch].textContent || '').toLowerCase();
                found = cellText.includes(searchValue);
            }

            row.style.display = found ? '' : 'none';
        }

        function updateFileName(input) {
            const fileName = input.files[0] ? input.files[0].name : 'No file chosen';
            document.getElementById('selectedFileName').textContent = fileName;

            // Automatically parse logs when file is selected
            if (input.files[0]) {
                parseLogs();
            }
        }

        function parseLogs() {
            const fileInput = document.getElementById('logFile');
            const errorMessage = document.getElementById('errorMessage');
            errorMessage.style.display = 'none';

            if (!fileInput.files || !fileInput.files[0]) {
                errorMessage.textContent = 'Please select a log file first';
                errorMessage.style.display = 'block';
                return;
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                const text = e.target.result;
                const lines = text.split('\n');
                const tbody = document.getElementById('logTableBody');
                tbody.innerHTML = '';

                lines.forEach(line => {
                    if (!line.trim() || !line.includes('Alert:')) return;

                    // Remove "Alert: " prefix and clean the line
                    line = line.replace(/^Alert:\s*/, '').trim();

                    // Updated regex pattern to match the sample log format
                    const pattern = /^(\d{2}\/\d{2}\/\d{2}-\d{2}:\d{2}:\d{2}\.\d+)\s+\[[\*]+\]\s+\[([^\]]+)\]\s+"([^"]+)"\s+\[[\*]+\]\s+\[Priority:\s*(\d+)\]\s+(?:\[AppID:\s*([^\]]+)\])?\s*{(\w+)}\s+(\S+)\s+->\s+(\S+)/;
                    
                    const match = line.match(pattern);

                    if (match) {
                        const [
                            ,
                            timestamp,
                            ruleId,
                            alertMessage,
                            priority,
                            appId,
                            protocol,
                            source,
                            destination
                        ] = match;

                        const row = tbody.insertRow();

                        // Add cells with the parsed data
                        row.insertCell().textContent = timestamp;
                        row.insertCell().textContent = ruleId;
                        row.insertCell().textContent = alertMessage;
                        row.insertCell().textContent = priority;
                        row.insertCell().textContent = protocol;
                        row.insertCell().textContent = source;
                        row.insertCell().textContent = destination;

                    } else {
                        console.warn("Could not parse log line:", line);
                    }
                });

                // Add search event listener after populating the table
                const searchInput = document.getElementById('search');
                searchInput.value = '';
                searchInput.addEventListener('input', searchLogs);
            };
            reader.readAsText(fileInput.files[0]);
        }

        function sortTable(columnIndex) {
            const table = document.getElementById('logTable');
            const tbody = table.tBodies[0];
            const rows = Array.from(tbody.rows);
            const isAscending = table.getAttribute('data-sort-asc') === 'true';

            rows.sort((rowA, rowB) => {
                const cellA = rowA.cells[columnIndex].textContent.trim();
                const cellB = rowB.cells[columnIndex].textContent.trim();

                if (!isNaN(cellA) && !isNaN(cellB)) {
                    return isAscending ? cellA - cellB : cellB - cellA;
                }

                return isAscending ? cellA.localeCompare(cellB) : cellB.localeCompare(cellA);
            });

            table.setAttribute('data-sort-asc', !isAscending);
            tbody.append(...rows);
        }

        function searchLogs() {
            try {
                const searchInput = document.getElementById('search');
                const searchText = searchInput.value.toLowerCase();
                const tbody = document.getElementById('logTableBody');
                const rows = tbody.getElementsByTagName('tr');

                // Define column mappings for search dorks
                const columnMap = {
                    'time:': 0,  // Timestamp
                    'id:': 1,    // Rule ID
                    'mess:': 2,  // Alert Message
                    'prio:': 3,  // Priority
                    'proto:': 4, // Protocol
                    'src:': 5,   // Source
                    'dst:': 6    // Destination
                };

                // Check if search uses a dork
                let columnToSearch = -1; // -1 means search all columns
                let searchValue = searchText;

                for (const [dork, column] of Object.entries(columnMap)) {
                    if (searchText.startsWith(dork)) {
                        columnToSearch = column;
                        searchValue = searchText.substring(dork.length);
                        break;
                    }
                }

                Array.from(rows).forEach(row => {
                    if (row.cells.length < 7) return; // Skip invalid rows

                    let found = false;
                    if (columnToSearch === -1) {
                        // Search all columns
                        for (let i = 0; i < row.cells.length; i++) {
                            const cellText = (row.cells[i].textContent || row.cells[i].innerText || '').toLowerCase();
                            if (cellText.includes(searchValue)) {
                                found = true;
                                break;
                            }
                        }
                    } else {
                        // Search specific column
                        const cellText = (row.cells[columnToSearch].textContent || row.cells[columnToSearch].innerText || '').toLowerCase();
                        found = cellText.includes(searchValue);
                    }

                    row.style.display = found ? '' : 'none';
                });
            } catch (error) {
                console.error('Search error:', error);
            }
        }

        // Update the search input placeholder to show available dorks
        document.getElementById('search').placeholder = "Search (use: mess:, id:, proto:, src:, dst:, prio:, time:)";
    </script>
    <!-- Quanh -->
    <script>
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        function switchToIPS() {
            
            fetch("{% url 'switch-to-ips' %}", {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert('Error switching to IPS mode: ' + data.error);
                } else {
                    alert('Successfully switched to IPS mode');
                    document.getElementById('switchModeBtn').disabled = true;
                    document.getElementById('logging').innerText = data.message;
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Error switching to IPS mode');
            });
        }
    </script>
    <script>
        function checkSnortStatus() {
            fetch('{% url "check-snort-status" %}')
                .then(response => response.json())
                .then(data => {
                    const statusDiv = document.getElementById('snortStatus');
                    const statusText = document.getElementById('statusText');
                    const streamButton = document.getElementById('streamButton');

                    if (data.running) {
                        statusDiv.style.display = 'block';
                        statusDiv.className = 'alert alert-success';
                        statusText.textContent = 'Capturing in progress';
                        streamButton.style.display = 'inline-block';
                        streamButton.disabled = true;  // Disable the button when capturing
                    } else {
                        statusDiv.style.display = 'block';
                        statusDiv.className = 'alert alert-secondary';
                        statusText.textContent = 'No active capture';
                        streamButton.style.display = 'none';
                        streamButton.disabled = false;  // Enable the button when not capturing
                    }
                })
                .catch(error => console.error('Error:', error));
        }

        function startStreaming() {
            window.location.href = '{% url "open_log_analyzer" %}?live=true';
        }
    
        // Check status every 5 seconds
        checkSnortStatus();
        setInterval(checkSnortStatus, 5000);
    </script>
</body>

</html>